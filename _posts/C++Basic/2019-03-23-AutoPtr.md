---
title: "C++Study-Auto_PTR"
date: 2019-03-32 23:20:00
categories: c++
---
# Auto_PTR
---

## Auto_PTR 을 사용하는 이유

- 일반적으로 객체를 생성하여 사용하는 경우에는, 객체의 사용이 끝났을 때(지역변수는 함수에서 나갈 때) 소멸자를 호출하여 내부의 리소스를 정리하도록 되어있다.
- **동적으로 리소스를 할당받은 경우에는** 사용자가 delete나 free를 호출하여 리소스를 제거해주지 않는한 소멸 되지 않으므로, 함수에서 나가게 되면 리소스를 할당받은 포인터 변수만 스택에서 제거 될 뿐 실제 할당 받은 리소스는 제거 되지 않으므로 메모리 누수가 발생
- 따라서, 이를 제어하기 위한 목적으로 auto_ptr 을 사용한다.

---
## auto_ptr의 기능

- auto_ptr은 동적으로 할당된 메모리를 자동으로 해제하는 기능을 가지는 포인터의 래퍼클래스이다.

```c++
template<typename T> class auto_ptr
```

- 위와 같이 정의 되어 있으며, 포인터가 가리키는 대상체의 타입을 T를 인수로 받아들이며, T*형의 포인터를 대신 관리한다.
- 파괴자에서 pointer가 가리키는 메모리도 자동으로 해제 시킨다.
- 따라서, delete나 free를 까먹을 것 같은 경우에는 자원관리 객체에 위임하는 것이 최고다!

---
## auto_ptr 의 한계
- auto ptr객체 끼리의 대입 시, 한쪽의 객체는 자신의 값을 NULL로 무효화 시킴으로써 두 객체가 한 대상을 가리키지 못한다는 한계가 분명히 존재한다.
- 이때, 사용하는 것이 스마트 포인터이다.
- tr::shared_ptr (RCSP :reference-counting smart pointer) : reference의 개수를 count하고 있다가, 만약 0이 되면 자동으로 삭제하는 스마트 포인터이다.
출처: https://pparkssunn.tistory.com/24 [공돌이끄적 스터디노트]
- 이 둘의 한계는 소멸자에서 delete를 호출하지 delete[]을 호출하지 않으므로, 배열에 사용 부적합하다.
- 따라서 배열은 vector나 string으로 사용하자.
